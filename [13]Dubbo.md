# 从RPC说起

在了解dubbo之前，首先需要聊聊什么是RPC，为什么要RPC

## 1.1 RPC是什么

### 1. 为什么需要RPC

提到RPC(Remote Procedure Call)，就躲不开提到分布式，这个促使RPC诞生的领域。

- 随着业务的发展，发展为分布式肯定是必然

以一个电商系统为例，我们会需要用户系统，订单系统，商品系统，当流量很小时，我们只需要一个单一应用就可以hold住；后来。这时候就需要一种机制，能让代码能像本地函数调用一样来调用分布在其他服务器下的方法。

> 假设你有一个Calculator，以及它的实现类CalculatorImpl，那么单体应用时，要调用Calculator的add方法来执行一个加运算，你可以方法中直接使用，因为在同一个地址空间，或者说在同一块内存，这个称为**本地函数调用**。
>
> 现在，将系统改造为分布式应用，接口调用和实现分别在两个子系统内，
>
> 服务A里头并没有CalculatorImpl这个类，那它要怎样调用服务B的CalculatorImpl的add方法呢?可以模仿B/S架构的调用方式，在B服务暴露一个Restful接口，然后A服务通过调用这个Restful接口来间接调用CalculatorImpl的add方法。
>
> 这样，已经很接近RPC了，不过，像这种每次调用时，是不是都需要写一串发起http请求的代码呢?比如httpClient.sendRequest...之类的，能不能简单一下，像本地方法调用一样，去发起远程调用，让使用者感知不到远程调用的过程。

所以，RPC要解决的两个问题：

- 解决分布式系统中，服务之间的调用问题。

- 远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑。

### 2. RPC基本流程

![RPC基本流程](images/13/RPC基本流程.png)

> 本节参考链接：https://www.cs.rutgers.edu/~pxk/417/notes/03-rpc.html

RPC的基本原理就如上图所示：左侧客户端想要调用服务端的一个方法，就通过一个stub存根（可以理解为一个小助理小助手的感觉），通过客户端与服务端架起的桥梁`socket`，经过网络传输将客户端的请求传到服务端，而服务端这边的一个stub接受到这个请求后，执行相应的服务端方法，再将得到的结果原路返回，这样一个通路就实现了RPC调用，使得两个在不同进程、不同服务器上的方法，能够像本地方法一样互相调用。

简而言之，RPC就是架起了一道桥梁。

### 3. 延伸：关键细节

延伸：以上两个点的实现，可以参考以下内容，可作为dubbo源码阅读的指引

> 链接：https://www.zhihu.com/question/25536695/answer/221638079
>
> **远程过程调用带来的新问题**
>
> 在远程调用时，我们需要执行的函数体是在远程的机器上的，也就是说，Multiply是在另一个进程中执行的。这就带来了几个新问题：
>
> 1. **Call ID映射**。我们怎么告诉远程机器我们要调用Multiply，而不是Add或者FooBar呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用Multiply，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 <--> Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。
> 2. **序列化和反序列化**。客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。
> 3. **网络传输**。远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。

综上所属，影响RPC的性能的关键主要有两点

- 网络通讯传输的效率

- 序列化反序列化的效率

  比如传输xml与json，就感觉xml比json的字符串长度长，也许就会慢一点？而如果传输的是二进制流，那说不定就比前两种更快。

## 1.2 为什么需要Dubbo

通过上文，我们知道了借助http等已有的协议，基于Restful相关规范，实现远程方法调用，那为什么还要大费周章的使用dubbo，使用一系列自定义的协议呢？

###  **问题1: RPC为什么用特有协议替代HTTP？**

> HTTP是一种协议,RPC可以通过 HTTP 来实现,也可以通过Socket自己实现一套协议来实现.所以题目可以换一种理解,为何 RPC 还有除 HTTP 之外的实现法,有何必要？
>
> [微服务调用为啥用RPC框架，Http不更简单吗？](https://developer.51cto.com/art/201904/595840.htm)

通俗点说，HTTP是一种通用的协议，可用范围广

- 利用现成的http协议进行传输，优点就是简单、直接
- HTTP接口由于受限于HTTP协议，需要带HTTP请求头，导致传输起来效率或者说安全性不如RPC，对于不断发展的业务肯定是有限的

但肯定比不上那种定制的协议高效：具体点说：

- RPC框架的好处首先就是长链接，不必每次通信都要像http一样去3次握手什么的，减少了网络开销;
- RPC在特定协议的基础上，可以更好的实现高级特性，RPC框架一般都有注册中心，有丰富的监控管理;发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。
  1. 比如dubbo的**注册中心**、**服务自动注册与发现**等特性。
  2. **负载均衡**、流量调度、灰度发布等等
  3. ....
- 安全性

### **问题2: dubbo有什么通讯协议？为什么要这么多？**为什么用？

1. dubbo有什么通信协议？

2. 为什么要这么多？

3. 为什么用？

   论复杂度，dubbo/hessian用起来是超级简单的。

   至于为什么用dubbo/hessian，有几点：

   一、是调用简单，真正提供了类似于调用本地方法一样调用接口的功能 。

   二、是参数返回值简单明了 参数和返回值都是直接定义在jar包里的，不需要二次解析。

   三、是 轻量，没有多余的信息。

   四、是便于管理，基于dubbo的注册中心。

### 问题3: dubbo 应用场景

Dubbo 的使用场景，可以从系统的演变讲起：

> 一个简单的电商网站说起，它可能包含如下的几个模块和功能，如首页、detail页、list页、下单页、支付页以及后台管理等页面和功能。单一的系统架构，使得在开发过程中，占用的资源越来越多，而且随着流量的增加使得维护起来越来越难以维护。
>
> 于是就产生了垂直应用架构，垂直应用架构解决了单一应用架构所面临的扩容问题，流量能够分散到各个子系统当中，且系统的体积可控，一定程度上降低了开发人员之间协同以及维护的成本，提升了开发效率。但是在垂直架构中相同逻辑代码需要不断的复制，不能复用。所以分布式系统就这样应运而生了。

> 随着服务化的进一步发展，服务越来越多，服务之间的调用和依赖关系也越来越复杂，诞生了面向服务的架构体系(SOA)，也因此衍生出了一系列相应的技术，如对服务提供、服务调用、连接处理、通信协议、序列化方式、服务发现、服务路由、日志输出等行为进行封装的服务框架。
>
> 就这样为分布式系统的服务治理框架就出现了，dubbo也就这样产生了。dubbo在整个分布式系统的架构中，按照分层的架构来架构，使得各个层级之间最大限度的松耦合.
>
> 原文链接：https://blog.csdn.net/chenli522/article/details/47082341

[TODO:dubbo和mq的使用场景](https://blog.csdn.net/zhangdaiscott/article/details/77751827)

# 整体架构

![dubbo-architucture](images/13/architecture.png)



**初始化过程`init`**

0. `start`容器启动；

1. `register`服务提供者将自己所提供的服务信息，注册到注册中心里面，这时候注册中心就知道有什么服务上线了；

2. `subscribe`当服务消费者启动时，就会向注册中心订阅，拿到相应的服务提供者所提供的服务

**运行时：同步(sync)异步(sync)**

3. `notify`并且，如果服务提供者的服务发生了变更，注册中心里的信息有了变化，注册中心也会通过长连接的形式将变更信息推送给消费者。

4. `invoke`消费者拿到所有需要的服务后，就可以同步的调用服务提供者的服务。
   并且 如果提供者有多台服务器提供服务 比如查询服务 那么消费者还可以根据负载均衡算法 来选择哪一台机器执行相应服务

5. `count`同时，每次的调用信息，比如调用时间、次数，会定时的将这些信息发送到监控中心，从而监控服务的运行状态。

值得注意的是，0、1、2是初始化启动时做的，3、5是异步，4的服务调用是同步的。

根据这个架构图，我们就知道了，当要编写dubbo应用时，就需要先写一个服务提供者，并注册到注册中心，然后写一个服务消费者，来订阅提供的服务，之后再测试如何调用提供的服务。

# 重要特性

【TODO】https://blog.csdn.net/prestigeding/article/details/80727275

## 一、SPI拓展点加载机制



## 二、服务注册

## 三、服务暴露服务引用机制

## 四、负载均衡策略

## 五、容错机制

## 六、路由

# 关键实现

> 作者：洪春涛
> 链接：https://www.zhihu.com/question/25536695/answer/221638079
> 来源：知乎
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
>
> 
>
> 有了这三个机制，就能实现RPC了，具体过程如下：
>
> ```cpp
> // Client端 
> //    int l_times_r = Call(ServerAddr, Multiply, lvalue, rvalue)
> 1. 将这个调用映射为Call ID。这里假设用最简单的字符串当Call ID的方法
> 2. 将Call ID，lvalue和rvalue序列化。可以直接将它们的值以二进制形式打包
> 3. 把2中得到的数据包发送给ServerAddr，这需要使用网络传输层
> 4. 等待服务器返回结果
> 5. 如果服务器调用成功，那么就将结果反序列化，并赋给l_times_r
> 
> // Server端
> 1. 在本地维护一个Call ID到函数指针的映射call_id_map，可以用std::map<std::string, std::function<>>
> 2. 等待请求
> 3. 得到一个请求后，将其数据包反序列化，得到Call ID
> 4. 通过在call_id_map中查找，得到相应的函数指针
> 5. 将lvalue和rvalue反序列化后，在本地调用Multiply函数，得到结果
> 6. 将结果序列化后通过网络返回给Client
> ```
>
> 所以要实现一个RPC框架，其实只需要按以上流程实现就基本完成了。
>
> 其中：
>
> - Call ID映射可以直接使用函数字符串，也可以使用整数ID。映射表一般就是一个哈希表。
> - 序列化反序列化可以自己写，也可以使用Protobuf或者FlatBuffers之类的。
> - 网络传输库可以自己写socket，或者用asio，ZeroMQ，Netty之类。

## 一、Call ID映射



## 二、序列化和反序列化



## 三、网络传输



# 关联中间件

## 一、netty

【TODO】

> **关于Netty**
>
> 大体上来说，Netty就是提供一种事件驱动的，责任链式（也可以说是流水线）的网络协议实现方式。网络协议包含很多层次，很多部分组成，如传输层协议，编码解码，压缩解压，身份认证，加密解密，请求的处理逻辑，怎么能够更好的复用，扩展，业界通用的方法就是责任链
>
> https://www.zhihu.com/question/25536695

## 二、zookeeper



# 存在的缺陷

# 带着问题回顾
> 常见面试题
>
> todo: https://www.jianshu.com/p/a66b83c450b2
>
> #### 14、Dubbo推荐使用什么序列化框架，你知道的还有哪些？
>
> 推荐使用Hessian序列化，还有Duddo、FastJson、Java自带序列化。
>
> #### 15、Dubbo默认使用的是什么通信框架，还有别的选择吗？
>
> Dubbo 默认使用 Netty 框架，也是推荐的选择，另外内容还集成有Mina、Grizzly。



> https://mp.weixin.qq.com/s/gYpZCSYK3YYEvGFFeHdFJQ
>
> dubbo服务暴露和引用过程，负载均衡策略，容错机制在哪里实现的源码
>
> dubbo服务调用过程（说着说着说到服务暴露和引用上面，他直接说这个之前问过了。。不用重复说，所以面试应该有记录面试问题）
>
> dubbo调用端怎么在jvm中生成对应服务？dubbo服务端和调用端超时时间设置和区别、dubbo长连接。