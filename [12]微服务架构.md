# 十二、架构
## SOA（面向服务的架构）
- 以可扩展标记语言（eXtensible Markup Language，XML）为基础的。通过使用基于XML（标准通用标记语言的子集） 的语言（称为 Web 服务描述语言（Web Services Definition Language，WSDL））来描述接口，服务已经转到更动态且更灵活的接口系统中
- 在一个企业内部，SOA服务通过一个扮演目录列表（directory listing）角色的登记处（Registry）来进行维护。应用程序在登记处（Registry）寻找并调用某项服务。
- 举一个具体的例子。一个服装零售组织拥有 500 家国际连锁店，它们常常需要更改设计来赶上时尚的潮流。这可能意味着不仅需要更改样式和颜色，甚至还可能需要更换布料、制造商和可交付的产品。如果零售商和制造商之间的系统不兼容，那么从一个供应商到另一个供应商的更换可能就是一个非常复杂的软件流程。通过利用 WSDL 接口在操作方面的灵活性，每个公司都可以将它们的现有系统保持现状，而仅仅匹配 WSDL 接口并制订新的服务级协定，这样就不必完全重构它们的软件系统了。这是业务的水平改变，也就是说，它们改变的是合作伙伴，而所有的业务操作基本上都保持不变。这里，业务接口可以作少许改变，而内部操作却不需要改变，之所以这样做，仅仅是为了能够与外部合作伙伴一起工作。

### RPC
- [基于RPC的电商平台内部SOA架构设计(TODO)](https://www.jianshu.com/p/68370b883995)
- RPC即远程过程调用，通俗一点就是跨进程跨主机的通信协议，用在SOA平台与上层业务平台之间的通信。
## 限流、熔断器与系统降级服务(TODO)
- 在今天，基于 SOA 的架构已经大行其道。伴随着架构的 **SOA** 化，相关联的服务熔断、降级、限流等思想，也在各种技术讲座中频繁出现。
- 限流在日常生活中也很常见，比如节假日你去一个旅游景点，为了不把景点撑爆，管理部门通常会在外面设置拦截，限制景点的进入人数。对应到计算机中，比如要搞活动，秒等，通常都会限流。有个关键问题就是：你根据什么策略进行限制？
- 假设一个请求的调用链上面有 10 个服务，只要这 10 个服务中有 1 个超时，就会导致这个请求超时。 更严重的，如果该请求的并发数很高，所有该请求在短时间内都被 block（等待超时），tomcat 的所有线程都 block 在此请求上，导致其他请求没办法及时响应。  
为了解决上述问题，服务熔断的思想被提出来。类似现实世界中的 “保险丝 “，当某个异常条件被触发，直接熔断整个服务，而不是一直等到此服务超时。熔断的触发条件可以依据不同的场景有所不同，比如统计一个时间窗口内失败的调用次数。
- [服务熔断、降级、限流、异步 RPC](https://blog.csdn.net/chunlongyu/article/details/53259014)
-  [Netflix 开源的 Hystrix 框架（TODO）](https://github.com/Netflix/Hystrix)
- [防雪崩利器：熔断器 Hystrix 的原理与使用](https://segmentfault.com/a/1190000005988895)
- [使用 Hystrix 实现自动降级与依赖隔离](http://www.importnew.com/25704.html)
## 限流

第4种是令牌桶算法限流，令牌桶算法从某种程度上来说是漏桶算法的一种改进，漏桶算法能够强行限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许某种程度的突发调用。

在令牌桶算法中，桶中会有一定数量的令牌，每次请求调用需要去桶中拿取一个令牌，拿到令牌后才有资格执行请求调用，否则只能等待能拿到足够的令牌数，读者看到这里，可能就认为是不是可以把令牌比喻成信号量，那和前面说的并发量限流不是没什么区别嘛？其实不然，令牌桶算法的精髓就在于“拿令牌”和“放令牌”的方式，这和单纯的并发量限流有明显区别，采用并发量限流时，当一个调用到来时，会先获取一个信号量，当调用结束时，会释放一个信号量，但令牌桶算法不同，因为每次请求获取的令牌数不是固定的。

比如当桶中的令牌数还比较多时，每次调用只需要获取一个令牌，随着桶中的令牌数逐渐减少，当到令牌的使用率（即使用中的令牌数/令牌总数）达某个比例，可能一次请求需要获取两个令牌，当令牌使用率到了一个更高的比例，可能一次请求调用需要获取更多的令牌数。同时，当调用使用完令牌后，有两种令牌生成方法，第一种就是直接往桶中放回使用的令牌数，第二种就是不做任何操作，有另一个额外的令牌生成步骤来将令牌匀速放回桶中。
- [常用限流方案的设计和实现](http://manzhizhen.iteye.com/blog/2311691)

## 缓存
- 随着互联网的普及，内容信息越来越复杂，用户数和访问量越来越大，我们的应用需要支撑更多的并发量，同时我们的应用服务器和数据库服务器所做的计算也越来越多。但是往往我们的应用服务器资源是有限的，且技术变革是缓慢的，数据库每秒能接受的请求次数也是有限的（或者文件的读写也是有限的），如何能够有效利用有限的资源来提供尽可能大的吞吐量？一个有效的办法就是引入缓存，打破标准流程，每个环节中请求可以从缓存中直接获取目标数据并返回，从而减少计算量，有效提升响应速度，让有限的资源服务更多的用户。

### 缓存特征
1. **命中率**
	- 命中率 = 返回正确结果数 / 请求缓存次数，命中率问题是缓存中的一个非常重要的问题，它是衡量缓存有效性的重要指标。命中率越高，表明缓存的使用率越高。
2. **最大元素（或最大空间）**
	- 缓存中可以存放的最大元素的数量，一旦缓存中元素数量超过这个值（或者缓存数据所占空间超过其最大支持空间），那么将会触发缓存启动清空策略根据不同的场景合理的设置最大元素值往往可以一定程度上提高缓存的命中率，从而更有效的时候缓存。
3. **清空策略**
	- 如上描述，缓存的存储空间有限制，当缓存空间被用满时，如何保证在稳定服务的同时有效提升命中率？这就由缓存清空策略来处理，设计适合自身数据特征的清空策略能有效提升命中率。常见的一般策略有：
		- FIFO(first in first out)

		先进先出策略，最先进入缓存的数据在缓存空间不够的情况下（超出最大元素限制）会被优先被清除掉，以腾出新的空间接受新的数据。策略算法主要比较缓存元素的创建时间。在数据实效性要求场景下可选择该类策略，优先保障最新数据可用。

		- LFU(less frequently used)

		最少使用策略，无论是否过期，根据元素的被使用次数判断，清除使用次数较少的元素释放空间。策略算法主要比较元素的 hitCount（命中次数）。在保证高频数据有效性场景下，可选择这类策略。

		- LRU(least recently used)

		最近最少使用策略，无论是否过期，根据元素最后一次被使用的时间戳，清除最远使用时间戳的元素释放空间。策略算法主要比较元素最近一次被 get 使用时间。在热点数据场景下较适用，优先保证热点数据的有效性。

### 缓存分类和应用场景
- **本地缓存**：指的是在应用中的缓存组件，其最大的优点是应用和 cache 是在同一个进程内部，请求缓存非常快速，没有过多的网络开销等，在单应用不需要集群支持或者集群情况下各节点无需互相通知的场景下使用本地缓存较合适；同时，它的缺点也是应为缓存跟应用程序耦合，多个应用程序无法直接的共享缓存，各应用或集群的各节点都需要维护自己的单独缓存，对内存是一种浪费。

- **分布式缓存**：指的是与应用分离的缓存组件或服务，其最大的优点是自身就是一个独立的应用，与本地应用隔离，多个应用可直接的共享缓存。

### 分布式缓存与本地缓存
#### A. [本地缓存](https://www.jianshu.com/p/866e8455e769)
- **为什么要用本地缓存**
	- 在系统中，有些数据，**数据量小，但是访问十分频繁**（例如国家标准行政区域数据或者一些数据字典等），针对这种场景，需要将数据搞到应用的本地缓存中，以提升系统的访问效率，减少无谓的数据库访问（数据库访问占用数据库连接，同时网络消耗比较大），但是有一点需要注意，就是缓存的占用空间以及缓存的失效策略。

	- 所谓的本地缓存是相对于网络而言的（包括集群，数据库访问等）

- **为什么是本地缓存，而不是分布式的集群缓存**
	- 很多情况的数据，大多是业务无关的（CodeMaster，数据字典等）数据缓存，没有必要搞分布式的集群缓存，再加上分布式缓存的构建，集群维护成本比较高，不太适合这种情况数据。

#### B. 分布式缓存
- [缓存在分布式系统中的应用](https://www.jianshu.com/p/3ac0d17293cd)
- [分布式缓存Redis使用以及原理](https://my.oschina.net/goodyj/blog/790389)


### 预运算/被动缓存

### 多级缓存架构

- [缓存那些事](https://tech.meituan.com/cache_about.html)
-----
## 序列化
**为什么需要序列化**

- 对象的序列化主要有两种用途：
		1. 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；
		2. 在网络上传送对象的字节序列。
- 在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。
- 当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。

- [参考链接：Java对象的序列化和反序列化](http://www.cnblogs.com/xdp-gacl/p/3777987.html)

//08/17
