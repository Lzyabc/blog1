# 一、Redis 简介

## 1. 特点

### （1）优点

- 性能极高：读 11w/s，写8.1w/s
- 丰富的数据类型：String，Hash，Set，OrderedSet等
- 原子性：所有操作都是原子的，也就是每次操作要么成功要么失败，单线程的形式，也就避免了加锁对性能的拖慢。
- 丰富的特性：publish、subscribe
- 高速读写：redis实现自己的分离器，代码量很短，没有使用锁（不像mysql中出现的行级锁表级锁），效率高

### （2）缺点

- 持久化：redis直接将数据存储在内存中，如果要持久化到磁盘中，需要使用两种方式：
  - 实时快照（snapshot）：每隔一段时间将整个数据库写到磁盘上，但**代价非常高**，效率慢
  - 追加（aof）：只追踪变化的数据，但追加的log会很大，回复的时候需要根据log重新执行一遍，**回复速度慢**。
- 内存占用高。

## 2. 安装

略

安装完成后，其实更多的是看看相应的conf文件，以下记录几个关键的参数

```bash
// 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合
save 900 1 // 900秒内（15分钟）内有一个修改
save 300 10
save 60 10000
```



# 二、内存维护策略

redis为了高速的读写，将数据存储在内存中，而这时候就会大量的占用内存，这时候就需要合理的内存维护策略来维持系统性能。

### 1. 两种解决方案

### （1）为数据设置超时时间

```bash
// expire key time（以秒为单位）--常用方式
expire k1 10
// setex key time value --字符串独有方式
setex k1 10 v1
// ttl k1 --可以查看过期时间
```

- 如果没有设置时间，那么缓存是永不过期
- 除了字符串独有外，其他的都是expire
- 设置过期时间后反悔想要永久：persist key

### （2）采用LRU算法

在redis-config中取消相应注释即可使用相应的策略。

【TODO】复制完善相关策略

# 三、常用指令

- EXPIRE key seconds
- Exists key

上面两个指令可以应用在以下场景：

1. 限时的优惠活动信息
2. 网站数据缓存（对于需要定时更新的数据，如积分排行榜）
3. 手机验证码
4. 限制访客访问频率

# 四、Redis数据类型

## 1. String

最基本类型，且其value不仅是string，也可以是多种特殊类型。

二进制安全的，意思就是redis的string可以包含任何信息：比如序列化的对象进行存储，一张图片进行二进制存储，一个类的存储。

string常用命令：

| 参数   | 解释                                                         |
| ------ | ------------------------------------------------------------ |
| Get    | Get key-name——获取存储在给定键中的值                         |
| Mget   | Mget key-name [key-name…]——获取存储在给定键中的值            |
| Incr   | Incr key-name——将键存储的值自增1。如果key存在，那存储的现有值必须是整数；如果key不存在，自增后get(key)=1 |
| Decr   | Decr key-name——将键存储的值自减1。如果key存在，那存储的现有值必须是整数；如果key不存在，自减后get(key)=-1 |
| 。。。 | 。。。                                                       |

比如上面的自增自减就可以用于高并发的计数器。

### 应用场景

1. String通常用于保存单个字符串或JSON字符串数据。
2. 因为String是二进制安全的，所以可以把一个图片文件的内容作为字符串来存储。
3. 计数器：常规kv缓存应用，常规计数：微博数，粉丝数。因为redis操作是原子性的，且没有多线程的并发问题。

例如基于INCR等指令原子性操作的特性，我们完全可以利用redis的INCR、DECR等指令实现原子技术的效果：

> 在某一个场景下有三个客户端读取了一个变量NUM的数值（值为2），并且同时进行了加一操作，那么最后NUM的值一定是5.
>
> 不少网站利用这个特性实现业务上的统计技术需求。
>
> 比如网站访问量、文章阅读量等。

## 2. Hash

类似一个map类型，很适合存储对象。

| 命  令                                        | 说  明                                 | 备  注     |
| --------------------------------------------- | -------------------------------------- | ---------- |
| 。。。                                        | 。。。                                 | 。。。     |
| hkeys key                                     | 返回 hash 中所有的键                   | ——         |
| hlen key                                      | 返回 hash 中键值对的数量               | ——         |
| hmget key field1[field2......]                | 返回 hash 中指定的键的值，可以是多个   | 依次返回值 |
| hmset key field1 value1 [field2 field2......] | hash 结构设置多个键值对                | ——         |
| hset key filed value                          | 在 hash 结构中设置键值对               | 单个设值   |
| hsetnx key field value                        | 当 hash 结构中不存在对应的键，才设置值 | ——         |
| hvals key                                     | 获取 hash 结构中所有的值               | ——         |

[参考：Redis哈希数据结构和常用命令](http://c.biancheng.net/view/4529.html)

可以看出，在 Redis 中的哈希结构和字符串有着比较明显的不同。

首先，命令都是以 h 开头，代表操作的是 hash 结构。

其次，大多数命令多了一个层级 field，这是 hash 结构的一个内部键，也就是说 Redis 需要通过 key 索引到对应的 hash 结构，再通过 field 来确定使用 hash 结构的哪个键值对。

### 应用场景

Hash的应用场景：存储一个用户信息对象数据

1. 常用于存储一个对象，并且比json等节省空间
2. 为什么不用string存储一个对象？
   - hash是最接近关系数据库结构的数据结构，可以将数据库一条记录或程序中的一个对象转换成hashmap存放在redis中：
   - 用户ID为查找的key（使用String），存储的value用户对象包含姓名，年龄名升入等信息，如果用普通的kv结构来存储，主要有以下两种存储方式：
     1. 第一种方式就是将用户ID作为查找key，其他信息封装成一个对象以序列化的方式存储，这种方式吃的缺点就是，增加了序列化和反序列化的开销，并且在需要修改其中一项信息时，需要将整个对象取回，并且修改操作需要对并发场景进行保护（修改时被读取），又会引入CAS等复杂问题。
     2. 第二种：如果把这个用户信息对象中的所有成员都设置为单独的kv，虽然省去了序列化开销和并发问题，但是大量重复存储，内存浪费严重。

**小结：**

redis的hash很好的解决了这个问题：存储一个用户信息对象数据。

## 3. List

List类型是一个链表结构的集合，其功能有push、pop、获取元素等。更详细的说，List类型是一个双端链表的结构，可以在集合的头部尾部添加和删除元素。List的设计简单精巧，可以作为栈，也可以作为队列。

### 常用命令

#### (1) push操作

```bash
RPUSH key value [value ...] #从队列的右边入队一个元素或多个元素，复杂度O(1)。
# 实际操作
redis> rpush queue a
(integer) 1
redis> rpush queue b
(integer) 2
redis> rpush queue c
(integer) 3
redis> rpush queue d e f
(integer) 6
redis> lrange queue 0 -1
1) "a"
2) "b"
3) "c"
4) "d"
5) "e"
6) "f"
```

PUSH和POP操作，其实是队列的基本操作。Redis的list就是一个极其强大的队列系统。我们在哪些地方会用到队列呢？下面，我们说两个例子：

**a，评论系统**

逛过微博的筒子们应该都对评论系统有了解。我们在看完一条微博之后，常常会评论一番，或者看看其他人的吐槽。每条评论的记录都是按照时间顺序排序的。我们读的时候也是这个顺序。这时，队列就是一个很好的存储结构。每提交一次评论，都向list的末尾添加一个新的节点。

当然，博客本身也可以是这样的结构。

**b，并行转串行**

我们做后台开发的筒子们应该都遇到过类似的情景。用户每时每刻都可能发出请求，而且请求的频率经常变化。这时，后台的程序不可能立刻响应每一个用户的请求，尤其是请求特别占资源的服务的时候（双11的时候，你有没有看到404页面？）。有什么好的办法来解决这个问题呢？我们需要一个排队系统。根据用户的请求时间，将用户的请求放入队列中，后台程序依次从队列中获取任务，处理并将结果返回到结果队列。

这其实也是一个生产者消费者模型。通过队列，我们将并行的请求转换成串行的任务队列，之后依次处理（当然后台的程序也可以多核并行处理）。

```bash
LPUSH key value [value ...] #从队列的左边入队一个或多个元素，复杂度O(1)。
# 这个指令和RPUSH几乎一样，只是插入节点的方向相反了，是从list的头部(左侧)进行插入的。
```

#### (2) pop操作

```bash
LPOP key # 从队列的左边出队一个元素，复杂度O(1)。如果list为空，则返回nil。
# 实际操作
redis> lrange queue 0 -1
 6 1) "a"
 7 2) "b"
 8 3) "c"
 9 4) "d"
10 5) "e"
11 6) "f"
12 redis> lpop queue
13 "a"
14 redis> lpop queue
15 "b"
16 redis> lrange queue 0 -1
17 1) "c"
18 2) "d"
19 3) "e"
20 4) "f"
```

同理，当然还有右侧的

```bash
RPOP key
# 从队列的右边出队一个元素，复杂度O(1)。如果list为空，则返回nil。
BLPOP key [key ...] timeout
# 删除，并获得该列表中的第一元素，或阻塞，直到有一个可用。
```



更多的操作可以参照

> 参考连接： [Redis基本操作——List（原理篇）](https://www.cnblogs.com/idiotgroup/p/5575236.html)

### 应用场景

项目常用于 1、对数据量大的集合数据删减；2、任务队列

1. **对数据量大的集合数据删减**

   列表数据显示、关注列表、粉丝列表、留言评论等

   热点新闻（top5）等

   利用LRANGE 可以实现分页的功能，在博客系统中，每篇博文的评论可以存在一个单独的list中。

   > 比如：获取最新的5条首页新闻，获取最新的评论，获取最后登陆的10个用户等。

2. **任务队列**

   实现一个保证先后顺序的消息队列。生产者消费者模式。



## 4. Set



## 5. ZSet



# 五、redis客户端

早期使用的是Jedis，一个老牌的redis的java实现客户端，还有redission。但SpringBoot2之后默认使用了Lettuce。

Redision促使使用者对redis的关注分离，提供很多分布式相关操作服务，例如分布式锁、分布式集合、通过redis实现延迟队列。

而我们基于springboot2，优先使用lettuce，如需使用分布式锁等分布式高级特性，添加redission结合使用。

> 在一些高并发场景中，比如秒杀、抢票、抢购这些场景，都存在对核心资源，商品库存的争夺，控制不好，库存数量可能被减少到负数，出现超卖的现象，或者产生位移的一个递增ID，由于web应用部署在多个机器上，简单的同步加锁是无法实现的，给数据库加锁的话，对于高并发（比如1000qps、1000次/s），数据库可能会由行锁变成表锁，性能严重下降。所以这个时候，redis的分布式锁就是一个很好的选择，redis官方推荐使用redission提供的分布式相关特性。







